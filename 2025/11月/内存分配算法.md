```c
 
Space AllocBoundTag (Space &pav, int n) {
    // 1. 查找符合条件的空闲块
    for (p = pav; p && p->size < n; p = p->rlink) {
        if (p == pav) return NULL; // 循环一圈未找到
    }
    if (!p || p->size < n) return NULL; // 未找到足够大的块

    // 2. 找到块p，f指向其底部
    f = FootLoc(p); // FootLoc(p)计算p的底部地址，通常为 p + p->size - 1

    // 3. 调整pav指针，指向p的后继（为下次分配做准备）
    pav = p->rlink;

    // 4. 判断剩余空间是否过小（<= e，e是系统规定阈值）
    if (p->size - n <= e) {
        // 4.1 分配整个块（不分割）
        if (pav == p) pav = NULL; // 如果链表只有一个结点，分配后链表为空
        else { // 从链表中移除p结点
            pav->llink = p->llink;
            p->llink->rlink = pav;
        }
        // 修改分配块的标志为“占用”
        f->tag = 1;
        p->tag = 1;
    } else {
        // 4.2 分割空闲块（高地址部分分配，低地址部分保留）
        // 调整剩余块的大小
        p->size -= n;
        // f指向新的剩余块的底部
        f = FootLoc(p);
        f->tag = 0; // 剩余块尾部标记为空闲
        f->uplink = p; // 尾部指向剩余块头部
        // p指向新分配块的头部
        p = f + 1; // 分配块在剩余块的高地址部分
        p->tag = 1; // 分配块头部标记为占用
        p->size = n; // 分配块的大小为n
    }
    // 5. 返回分配块的起始地址
    return p;
}
 
```